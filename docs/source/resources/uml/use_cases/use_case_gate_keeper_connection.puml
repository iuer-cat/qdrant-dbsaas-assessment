@startuml

|GateKeeper|
start
partition Twisted.reactor {
:Any HTTP Request Qdrant API compatible
on any HTTP Method (GET,POST...)
e.g. ""/collections/{collection_name}/points"";
}

partition CustomReverseProxyResource {
:getChild(); <<task>>
note left
    Twisted ReverseProxyResource that
    allow us to modify the HTTP
    Request before proxying the
    connection.
end note

    partition HeaderEnforcer {
    :Ensure 'Host' and 'api-key'
    headers are present. ; <<task>>
    note left
    The Host Header should match with
    the generated endpoint created during
    the cluster provision.
    end note

    split
        if (**""Host""** exists?) then (yes)
        else (no)
            :404 NotFound;
            stop
        endif
    split again
        if (**""api-key""** exists?) then (yes)
        else (no)
            :401 Unauthorized;
            stop
        endif
    end split
    }
}

partition RoutingService {
:intercept_request(request: Request); <<task>>
}

partition ApiKeyEnforcingService {
split
    if (is_valid_endpoint?) then (yes)
    else (no)
        :404 NotFound;
        stop
    endif
split again
    if (is_valid_api_key?) then (yes)
    else (no)
        :401 Unauthorized;
        stop
    endif
end split

}

:ProxyRequest; <<output>>
note left
""original: Route""
**""proxy_to: Optional[Route]""**
**""authenticated: bool""**
""additional_headers: Dict[str, str]""
end note

partition CustomReverseProxyResource {
:setRawHeaders('**api-key**'); <<task>>
}
note left
Replace Salt Hashing *api-key*
for the **Qdrant DB Cluster api-key**
before re-routing the Request.
end note

:**Proxy-Pass** Modified
Request to destination; <<output>>

partition Kubernetes Cluster {
note left
Te Request to the Qdrant DB
Cluster will be balanced following
the internal Kubernetes Configuration
across Qdrant nodes.
end note

    split
        :K8s Service (LoadBalancer);
    end split
}

stop

@enduml